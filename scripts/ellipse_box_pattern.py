# -*- coding: utf-8 -*-
"""Ellipse_Box_Pattern.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OZaNs1iXaSLh__zC_ikIrToby6v-EEWk
"""

import numpy as np
from skimage import filters, morphology, measure
from scipy import ndimage

from .pattern import PerCellPatternMethod
from . import DataDock

class EllipseBoxPattern(PerCellPatternMethod):
    """
    For each segmented embryo:
    - Segment the embryo from raw image
    - Fit ellipse (via regionprops)
    - Find endpoints of the major axis
    - Draw solid boxes of light at those endpoints
    """

    name = "ellipse_box"

    def __init__(
        self,
        experiment_name,
        camera_properties,
        channel=None,
        coverage=30,
        min_area=1000,
        smoothing_sigma=2,
        **kwargs
    ):
        super().__init__(experiment_name, camera_properties, channel, **kwargs)
        self.coverage = coverage  # size of the square boxes in pixels (as % of major axis)
        self.min_area = min_area  # minimum area for valid embryo region
        self.smoothing_sigma = smoothing_sigma  # gaussian smoothing parameter

    def initialize(self, experiment):
        super().initialize(experiment)

        channel = experiment.channels.get(self.channel, None)
        assert channel is not None, f"provided channel {self.channel} is not in experiment"

        self.seg_channel_id = channel.channel_id

        # Request raw (non-segmented) image
        raw_image_request = AcquiredImageRequest(channel.channel_id, False, False)

        return [raw_image_request]

    def segment_embryo(self, image):
        """
        Simple binary segmentation to isolate fly embryo.

        Parameters:
        -----------
        image : np.ndarray
            Input grayscale image

        Returns:
        --------
        binary_mask : np.ndarray
            Binary mask with embryo segmented
        """
        # Smooth image to reduce noise
        smoothed = filters.gaussian(image, sigma=self.smoothing_sigma)

        # Otsu threshold for binary segmentation
        thresh = filters.threshold_otsu(smoothed)
        binary = smoothed > thresh

        # Clean up: remove small objects, fill holes
        binary = morphology.remove_small_objects(binary, min_size=self.min_area)
        binary = ndimage.binary_fill_holes(binary)

        # Keep only largest connected component (the embryo)
        labeled = measure.label(binary)
        if labeled.max() == 0:
            return binary.astype(np.uint8)

        regions = measure.regionprops(labeled)
        largest_region = max(regions, key=lambda r: r.area)
        binary = labeled == largest_region.label

        return binary.astype(np.uint8)

    @staticmethod
    def draw_oriented_box(mask, cx, cy, width, height, angle):
        """
        Draw a filled oriented rectangle into mask.

        Parameters:
        -----------
        mask : np.ndarray
            2D array to draw into
        cx, cy : float
            Center of rectangle (in local coords, relative to prop.bbox)
        width, height : float
            Dimensions in pixels
        angle : float
            Rotation in radians (counter-clockwise)

        Returns:
        --------
        mask : np.ndarray
            Modified mask with box drawn
        """
        yy, xx = np.meshgrid(
            np.arange(mask.shape[0]),
            np.arange(mask.shape[1]),
            indexing="ij"
        )

        # Shift coordinates relative to center
        x_rel = xx - cx
        y_rel = yy - cy

        # Rotate coords
        xr = x_rel * np.cos(angle) + y_rel * np.sin(angle)
        yr = -x_rel * np.sin(angle) + y_rel * np.cos(angle)

        # Fill mask inside box bounds
        inside = (np.abs(xr) <= width/2) & (np.abs(yr) <= height/2)
        mask[inside] = 1.0

        return mask

    def process_prop(self, prop):
        """
        Process a single regionprop to create illumination pattern.

        Parameters:
        -----------
        prop : RegionProperties
            Regionprop from skimage.measure.regionprops

        Returns:
        --------
        mask : np.ndarray
            Pattern mask with boxes at ellipse endpoints
        """
        mask = np.zeros_like(prop.image, dtype=np.float32)

        y0, x0 = prop.centroid_local
        major = prop.major_axis_length
        minor = prop.minor_axis_length
        orientation = prop.orientation + np.pi/2  # rotate to major axis

        # Endpoints of major axis
        x1 = x0 + 0.5 * major * np.cos(orientation)
        y1 = y0 - 0.5 * major * np.sin(orientation)

        x2 = x0 - 0.5 * major * np.cos(orientation)
        y2 = y0 + 0.5 * major * np.sin(orientation)

        # Box dimensions
        width = minor
        height = major * self.coverage / 100.0

        # Draw oriented boxes at each endpoint
        mask = self.draw_oriented_box(mask, x1, y1, width, height, orientation)
        mask = self.draw_oriented_box(mask, x2, y2, width, height, orientation)

        return mask

    def process(self, data_dock: DataDock):
        """
        Main processing method: segment embryo and create pattern.

        Parameters:
        -----------
        data_dock : DataDock
            Data access object from pyclm

        Returns:
        --------
        pattern_mask : np.ndarray
            Full-size pattern mask for illumination
        """
        # Get raw image
        raw_image = data_dock.get_image(self.seg_channel_id, segmented=False)

        # Segment embryo
        binary_mask = self.segment_embryo(raw_image)

        # Get regionprops from segmented mask
        labeled = measure.label(binary_mask)
        props = measure.regionprops(labeled)

        # If no embryo found, return empty pattern
        if len(props) == 0:
            return np.zeros_like(raw_image, dtype=np.float32)

        # Create full-size pattern mask
        pattern_mask = np.zeros_like(raw_image, dtype=np.float32)

        # Process each region (typically should be just one embryo)
        for prop in props:
            # Get local pattern for this region
            local_mask = self.process_prop(prop)

            # Place into full image using bounding box
            min_row, min_col, max_row, max_col = prop.bbox
            pattern_mask[min_row:max_row, min_col:max_col][prop.image] = \
                local_mask[prop.image]

        return pattern_mask